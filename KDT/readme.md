### 인터넷 검색을 허용하는 경우에는 자기 깃허브도 사용 가능

## 최신 출제 경향

1년전과 동일함

2~5시간 정도 시간을 줌
고급 알고리즘은 물어보지 않음

구현/DFS/BFS/그리디
요즘은 이것보다는 좀 더 다양하게 나오는 편 (카카오는 이분탐색 많이 나옴)

DFS/BFS 위주 탐색 문제 출제 경향 유지
난이도는 점점 어려워짐
기출 문제 최대한 많이 접하기

- 1단계: 프로그래밍 언어 문법 공부 Python/C++/Java/JavaScript
- 2단계: 코드업에서 쉬운 문제부터 200문제가량 풀기
- 3단계: 유형별 알고리즘 이론과 핵심 문제 풀이 (나동빈 책 참고)
- 4단계: 백준 온라인 저지에서 유형별 문제 20개 이상 풀기
- 5단계: 백준 온라인 저지에서 삼성 SW 역량테스트 문제집 풀기
- 6단계: 프로그래머스 카카오 문제집 풀기
- 7단계: 주요 알고리즘 유형 복습하면서 골드 1~5 문제 마스터
  (타이트한 일정)

자바스크립트 기준 1초에 2~3천만개의 연산을 수행 -> 시간복잡도에 이용하기

1. 그리디 알고리즘이 시간을 만족할까?
2. DFS/BFS로 완탐하면 되나?
3. 안되면 DP를 이용해보자

O(logN) -> 이분탐색
O(N) -> for문 1번
O(NlogN) -> 보통 정렬 알고리즘
재귀함수 나올 때가 조금 구하기 어렵긴 함

for문 두번이 n^2는 아니고 내부적으로 호출하는 함수 안에 반복문까지 고려한다.

시간과 공간을 적절하게 사용하는게 좋음

문제에서 가장 먼저 확인해야 하는 내용은 시간제한(수행시간 요구사항)입니다.

- 시간제한이 1초인 문제를 만났을 때, 일반적인 기준은 다음과 같습니다.
- N의 범위가 500인 경우: 시간 복잡도가 𝑂(𝑁3)인 알고리즘을 설계하면 문제를 풀 수 있습니다.
- N의 범위가 2,000인 경우: 시간 복잡도가 𝑂(𝑁2)인 알고리즘을 설계하면 문제를 풀 수 있습니다.
- N의 범위가 100,000인 경우: 시간 복잡도가 𝑂 𝑁𝑙𝑜𝑔𝑁 인 알고리즘을 설계하면 문제를 풀 수 있습니다.
- N의 범위가 10,000,000인 경우: 시간 복잡도가 𝑂(𝑁)인 알고리즘을 설계하면 문제를 풀 수 있습니다.

지문 읽기가 생각보다 어렵다.
지문을 잘 읽고 요구사항을 파악한다.

어지간하면 문제 푸는 사람들은 간결하게 푸는 방법을 만들어놓고 풀 수 있다.
그러니까 그런 방법이 있다고 믿고 푼다. (엄청 중요)

```javascript
let summary = 0
// getTime(): 1970-01-01부터의 시간차를 ms 단위로 계산
let startTime = new Date().getTime()
// 1부터 1,000,000까지의 수를 더한 결과 계산
for (let i = 1; i <= 1000000; i++) {
  summary += i
}
let endTime = new Date().getTime()
// 시간차 출력
console.log(endTime - startTime)
```

Number()로 변환하는게 가장 빠르다.

메모리 제한
배열 크기
재귀 => 스택 호출(컴퓨터 구조) => 스택 개수에 비례하는만큼 변수
정밀하게 계산하는 방법은 없고 경험적으로 유추해야한다.

DFS/BFS로 골라서 풀 수 있는 문제는 BFS를 이용한다.
그리고 queue가 메모리도 적게 쓰고 빠르기 때문에 그런 관점에서도 BFS가 좋다.
코드 한줄 차이로 터지거나 안터지거나 하는 경우에도 경험적인거나 테크닉을 알고 해결하는 것으로..
